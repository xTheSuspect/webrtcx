<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>P2P File Transfer (WebRTC)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jsqr/dist/jsQR.js"></script>

<style>
body {
  font-family: Arial, sans-serif;
  background: #f4f6f8;
  padding: 16px;
}
h2 {
  text-align: center;
}
button, textarea, input {
  width: 100%;
  margin: 6px 0;
  padding: 12px;
  font-size: 16px;
}
textarea {
  height: 120px;
}
canvas, video {
  width: 100%;
  max-height: 300px;
}
.status {
  text-align: center;
  font-weight: bold;
  margin: 10px 0;
}
progress {
  width: 100%;
  height: 18px;
}
</style>
</head>

<body>

<h2>üîó P2P File Transfer</h2>

<!-- Pairing -->
<button onclick="createOffer()">üñ•Ô∏è Create Offer (PC)</button>
<button onclick="startScan('offer')">üì± Scan Offer QR (Phone)</button>

<button onclick="createAnswer()">üì± Create Answer</button>
<button onclick="startScan('answer')">üñ•Ô∏è Scan Answer QR (PC)</button>

<textarea id="signal" placeholder="Or copy / paste offer or answer here"></textarea>
<button onclick="applySignal()">Apply Pasted Signal</button>

<canvas id="qr"></canvas>
<video id="video" autoplay muted hidden></video>

<div class="status" id="status">Status: Idle</div>

<hr>

<!-- File transfer -->
<input type="file" id="fileInput">
<button onclick="sendFile()">üöÄ Send File</button>
<progress id="prog" value="0" max="100"></progress>

<script>
/* ---------------- GLOBALS ---------------- */
let pc = new RTCPeerConnection();
let channel;
let receiveBuffer = [];
let incomingFileInfo = null;
let scanMode = null;

const statusEl = document.getElementById("status");
const signalEl = document.getElementById("signal");
const canvas = document.getElementById("qr");
const ctx = canvas.getContext("2d");
const video = document.getElementById("video");

/* ---------------- HELPERS ---------------- */
function setStatus(text) {
  statusEl.textContent = "Status: " + text;
}

/* ---------------- ICE / SIGNAL ---------------- */
pc.onicecandidate = e => {
  if (!e.candidate) {
    const data = JSON.stringify(pc.localDescription);
    signalEl.value = data;
    QRCode.toCanvas(canvas, data);
  }
};

pc.ondatachannel = e => {
  channel = e.channel;
  setupChannel();
};

/* ---------------- DATA CHANNEL ---------------- */
function setupChannel() {
  channel.binaryType = "arraybuffer";

  channel.onopen = () => setStatus("Connected ‚úÖ");

  channel.onmessage = e => {
    if (typeof e.data === "string") {
      const msg = JSON.parse(e.data);

      if (msg.type === "meta") {
        incomingFileInfo = msg;
        receiveBuffer = [];
      }

      if (msg.type === "done") {
        const blob = new Blob(receiveBuffer, {
          type: incomingFileInfo.mime
        });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = incomingFileInfo.name;
        a.click();
        receiveBuffer = [];
        incomingFileInfo = null;
      }
    } else {
      receiveBuffer.push(e.data);
    }
  };
}

/* ---------------- OFFER / ANSWER ---------------- */
async function createOffer() {
  channel = pc.createDataChannel("file");
  setupChannel();
  await pc.setLocalDescription(await pc.createOffer());
  setStatus("Offer created");
}

async function createAnswer() {
  const data = JSON.parse(signalEl.value);
  await pc.setRemoteDescription(data);
  await pc.setLocalDescription(await pc.createAnswer());
  setStatus("Answer created");
}

async function applySignal() {
  const data = JSON.parse(signalEl.value);
  await pc.setRemoteDescription(data);
  setStatus("Signal applied");
}

/* ---------------- FILE SEND ---------------- */
async function sendFile() {
  if (!channel || channel.readyState !== "open") {
    alert("Not connected yet");
    return;
  }

  const file = fileInput.files[0];
  if (!file) return alert("Select a file");

  // Send metadata
  channel.send(JSON.stringify({
    type: "meta",
    name: file.name,
    size: file.size,
    mime: file.type
  }));

  const chunkSize = 16384;
  let offset = 0;

  while (offset < file.size) {
    const slice = file.slice(offset, offset + chunkSize);
    channel.send(await slice.arrayBuffer());
    offset += chunkSize;
    prog.value = (offset / file.size) * 100;
  }

  channel.send(JSON.stringify({ type: "done" }));
}

/* ---------------- QR SCAN ---------------- */
function startScan(type) {
  scanMode = type;
  navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
    .then(stream => {
      video.srcObject = stream;
      video.hidden = false;
      requestAnimationFrame(scanLoop);
    });
}

function scanLoop() {
  if (video.readyState === video.HAVE_ENOUGH_DATA) {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0);
    const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const code = jsQR(img.data, img.width, img.height);
    if (code) {
      signalEl.value = code.data;
      video.srcObject.getTracks().forEach(t => t.stop());
      video.hidden = true;
      if (scanMode === "offer") createAnswer();
      else applySignal();
      return;
    }
  }
  requestAnimationFrame(scanLoop);
}
</script>

</body>
</html>