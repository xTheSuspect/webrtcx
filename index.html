<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>P2P File Transfer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>

<style>
body {
  font-family: Arial, sans-serif;
  background: #f4f6f8;
  padding: 16px;
}
h2 {
  text-align: center;
}
button, input {
  width: 100%;
  padding: 12px;
  margin: 8px 0;
  font-size: 16px;
}
canvas {
  width: 100%;
}
.status {
  text-align: center;
  font-weight: bold;
  margin: 10px 0;
}
progress {
  width: 100%;
  height: 18px;
}
</style>
</head>

<body>

<h2>ðŸ”— P2P File Transfer</h2>

<canvas id="qr"></canvas>
<div class="status" id="status">Waitingâ€¦</div>

<hr>

<input type="file" id="fileInput">
<button onclick="sendFile()">ðŸš€ Send File</button>
<progress id="prog" value="0" max="100"></progress>

<script>
/* ===== CONFIG ===== */
const SIGNALING_URL = "wss://YOUR-RAILWAY-URL"; // â† PUT YOUR URL HERE

/* ===== GLOBALS ===== */
const pc = new RTCPeerConnection();
let channel;
let receiveBuffer = [];
let incomingFile = null;

/* ===== ROOM ===== */
const ROOM = location.hash.substring(1) ||
             Math.random().toString(36).slice(2);

/* ===== STATUS ===== */
const statusEl = document.getElementById("status");
const setStatus = t => statusEl.textContent = t;

/* ===== SIGNALING ===== */
const ws = new WebSocket(SIGNALING_URL);

ws.onopen = async () => {
  ws.send(JSON.stringify({ type: "join", room: ROOM }));

  // PC side (no hash initially)
  if (!location.hash) {
    channel = pc.createDataChannel("file");
    setupChannel();

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    ws.send(JSON.stringify({ offer }));

    const url = location.origin + "/#" + ROOM;
    QRCode.toCanvas(document.getElementById("qr"), url);
    setStatus("Scan QR from phone");
  }
};

ws.onmessage = async e => {
  const msg = JSON.parse(e.data);

  if (msg.offer && !pc.currentRemoteDescription) {
    await pc.setRemoteDescription(msg.offer);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    ws.send(JSON.stringify({ answer }));
  }

  if (msg.answer) {
    await pc.setRemoteDescription(msg.answer);
  }

  if (msg.ice) {
    await pc.addIceCandidate(msg.ice);
  }
};

pc.onicecandidate = e => {
  if (e.candidate) {
    ws.send(JSON.stringify({ ice: e.candidate }));
  }
};

pc.ondatachannel = e => {
  channel = e.channel;
  setupChannel();
};

/* ===== DATA CHANNEL ===== */
function setupChannel() {
  channel.binaryType = "arraybuffer";

  channel.onopen = () => setStatus("Connected âœ…");

  channel.onmessage = e => {
    if (typeof e.data === "string") {
      const msg = JSON.parse(e.data);

      if (msg.type === "meta") {
        incomingFile = msg;
        receiveBuffer = [];
      }

      if (msg.type === "done") {
        const blob = new Blob(receiveBuffer, { type: incomingFile.mime });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = incomingFile.name;
        a.click();
        incomingFile = null;
        receiveBuffer = [];
      }
    } else {
      receiveBuffer.push(e.data);
    }
  };
}

/* ===== SEND FILE ===== */
async function sendFile() {
  if (!channel || channel.readyState !== "open") {
    alert("Not connected yet");
    return;
  }

  const file = fileInput.files[0];
  if (!file) return;

  channel.send(JSON.stringify({
    type: "meta",
    name: file.name,
    size: file.size,
    mime: file.type
  }));

  const chunk = 16384;
  let offset = 0;

  while (offset < file.size) {
    const slice = file.slice(offset, offset + chunk);
    channel.send(await slice.arrayBuffer());
    offset += chunk;
    prog.value = (offset / file.size) * 100;
  }

  channel.send(JSON.stringify({ type: "done" }));
}
</script>

</body>
</html>